# Enterprise Loan Management System with DDD, Hexagonal Architecture, and SAGA Pattern

## Overview

This document outlines the requirements and architecture for building a production-ready Loan Management System for a bank using Java 21, Spring Boot 3.2, following Domain-Driven Design (DDD) principles and Hexagonal Architecture. The system will be deployed on AWS EKS (Kubernetes) following the AWS Well-Architected Framework, with a complete local development environment and SAGA pattern for distributed transactions.

## Table of Contents

1. [Business Requirements](#business-requirements)
2. [Technical Architecture Requirements](#technical-architecture-requirements)
3. [AWS Well-Architected Framework Implementation](#3-aws-well-architected-framework-implementation)
4. [Kubernetes Deployment Architecture](#4-kubernetes-deployment-architecture)
5. [Technology Stack](#5-technology-stack)
6. [Local Development Environment](#6-local-development-environment)
7. [API Design](#7-api-design)
8. [Event-Driven Architecture with SAGA Pattern](#8-event-driven-architecture-with-saga-pattern)
9. [Testing Strategy](#9-testing-strategy)
10. [Documentation Requirements](#10-documentation-requirements)
11. [Observability Requirements](#11-observability-requirements)
12. [Security Requirements](#12-security-requirements)

## Business Requirements

Build a backend Loan API system that enables bank employees to manage customer loans with the following capabilities:

### Core Features

#### 1. Create Loan
- Validate customer has sufficient credit limit
- Support only 6, 9, 12, or 24 installments
- Interest rate between 0.1 and 0.5
- Calculate total loan amount as: principal × (1 + interest rate)
- Generate equal installments with due dates on the first day of each month
- First installment due on the first day of next month

#### 2. List Loans
- List all loans for a given customer
- Support filtering by: number of installments, payment status

#### 3. List Installments
- List all installments for a specific loan

#### 4. Process Payments
- Support multiple installment payments in a single transaction
- Enforce whole installment payments only (no partial payments)
- Pay earliest unpaid installments first
- Restrict advance payments to maximum 3 months
- Return payment summary: installments paid, total amount spent, loan completion status
- Update customer credit limit when loan is fully paid

### Business Rules

#### 1. Payment Discounts/Penalties
- Early payment discount: amount × 0.001 × days before due date
- Late payment penalty: amount × 0.001 × days after due date

#### 2. Security Requirements
- Role-based access control (RBAC)
- ADMIN role: Can manage all customers and loans
- CUSTOMER role: Can only view/pay their own loans

### Data Model

```sql
Customer: id, name, surname, creditLimit, usedCreditLimit
Loan: id, customerId, loanAmount, numberOfInstallment, createDate, isPaid
LoanInstallment: id, loanId, amount, paidAmount, dueDate, paymentDate, isPaid
```

## Technical Architecture Requirements

### 1. Domain-Driven Design Structure

Implement the following bounded contexts:

```
loan-management-system/
├── customer-management/     # Customer bounded context
├── loan-origination/       # Loan creation and management
├── payment-processing/     # Payment handling
└── shared-kernel/         # Shared value objects and interfaces
```

Each bounded context should follow hexagonal architecture:

```
bounded-context/
├── domain/
│   ├── model/
│   │   ├── aggregate/     # Aggregate roots
│   │   ├── entity/        # Entities
│   │   └── value/         # Value objects
│   ├── event/            # Domain events
│   ├── service/          # Domain services
│   └── port/             # Port interfaces
│       ├── in/           # Input ports (use cases)
│       └── out/          # Output ports (repositories)
├── application/
│   ├── service/          # Application services
│   ├── saga/            # SAGA orchestrators
│   └── port/
│       └── in/           # Use case implementations
└── infrastructure/
    ├── adapter/
    │   ├── in/           # Input adapters
    │   │   ├── web/      # REST controllers
    │   │   └── event/    # Event listeners
    │   └── out/          # Output adapters
    │       ├── persistence/  # JPA repositories
    │       └── messaging/    # Event publishers
    └── config/           # Spring configurations
```

### 2. Key Domain Concepts

Implement these as rich domain models:

- **Value Objects**: Money, InterestRate, InstallmentCount, CustomerId, LoanId
- **Aggregates**: Customer (with credit management), Loan (with installments)
- **Domain Events**: LoanCreated, PaymentProcessed, CreditReserved, CreditReleased
- **Domain Services**: CreditAssessmentService, PaymentCalculationService

### 3. AWS Well-Architected Framework Implementation

#### Operational Excellence
- Implement comprehensive logging with correlation IDs
- Use AWS CloudWatch for centralized logging
- Implement distributed tracing with AWS X-Ray
- Create runbooks for common operations
- Use Infrastructure as Code (Terraform/CloudFormation)

#### Security
- Implement OAuth 2.0 / JWT authentication
- Use AWS Secrets Manager for credentials
- Enable encryption at rest and in transit
- Implement API rate limiting
- Use AWS WAF for API protection
- Follow principle of least privilege with IAM roles

#### Reliability
- Design for failure with circuit breakers (Resilience4j)
- Implement retry mechanisms with exponential backoff
- Use AWS RDS Multi-AZ for database high availability
- Implement health checks and readiness probes
- Set up auto-scaling based on metrics
- Use SQS for reliable event processing

#### Performance Efficiency
- Implement caching strategy with Redis (ElastiCache)
- Use read replicas for query operations
- Implement CQRS for read/write separation
- Use database connection pooling
- Optimize JPA queries with proper indexing
- Implement pagination for list endpoints

#### Cost Optimization
- Use AWS Cost Explorer for monitoring
- Implement request throttling
- Use spot instances for non-critical workloads
- Set up lifecycle policies for logs and backups
- Right-size compute resources based on metrics

#### Sustainability
- Implement efficient algorithms for calculations
- Use server-side pagination
- Minimize data transfer with proper DTOs
- Schedule batch operations during off-peak hours

### 4. Kubernetes Deployment Architecture

```yaml
# Example namespace structure
namespaces:
  - loan-system-dev
  - loan-system-staging
  - loan-system-prod

# Microservices deployment
services:
  - customer-service
  - loan-service
  - payment-service
  - api-gateway

# Required Kubernetes resources
resources:
  - Deployments with rolling updates
  - Services for internal communication
  - Ingress for external access
  - ConfigMaps for configuration
  - Secrets for sensitive data
  - HorizontalPodAutoscaler for auto-scaling
  - PodDisruptionBudgets for reliability
  - NetworkPolicies for security
```

### 5. Technology Stack

```yaml
Core:
  - Java 21 with Virtual Threads
  - Spring Boot 3.2
  - Spring Data JPA
  - Spring Security with JWT
  - Spring Cloud Gateway for API Gateway

Database:
  - PostgreSQL for production (AWS RDS)
  - H2 for local development and testing
  - Flyway for database migrations

Messaging:
  - Apache Kafka for event streaming (AWS MSK)
  - Spring Cloud Stream for event handling

Caching:
  - Redis for distributed caching (AWS ElastiCache)
  - Caffeine for local caching

Monitoring:
  - Micrometer for metrics
  - Spring Boot Actuator
  - Prometheus + Grafana
  - ELK Stack for logging
  - Jaeger for distributed tracing

Testing:
  - JUnit 5 with Jupiter
  - Mockito for mocking
  - TestContainers for integration tests
  - ArchUnit for architecture tests
  - REST Assured for API tests

Build & Deploy:
  - Gradle for build management
  - Docker for containerization
  - Helm for Kubernetes packaging
  - GitHub Actions for CI/CD
  - ArgoCD for GitOps deployment
```

### 6. Local Development Environment

Provide a complete local development setup:

```yaml
# docker-compose.yml for local development
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: loandb
      POSTGRES_USER: loan_user
      POSTGRES_PASSWORD: loan_pass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  kafka:
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092

  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    ports:
      - "2181:2181"
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  localstack:
    image: localstack/localstack
    ports:
      - "4566:4566"
    environment:
      - SERVICES=s3,sqs,secretsmanager
      - DEBUG=1
      - DATA_DIR=/tmp/localstack/data
    volumes:
      - localstack_data:/tmp/localstack

volumes:
  postgres_data:
  localstack_data:
```

### 7. API Design

Design RESTful APIs following OpenAPI 3.0 specification:

```yaml
openapi: 3.0.0
info:
  title: Loan Management API
  version: 1.0.0

paths:
  /api/v1/loans:
    post:
      summary: Create a new loan
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateLoanRequest'
      responses:
        '201':
          description: Loan created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LoanResponse'

  /api/v1/customers/{customerId}/loans:
    get:
      summary: List loans for a customer
      security:
        - bearerAuth: []
      parameters:
        - name: customerId
          in: path
          required: true
          schema:
            type: integer
        - name: numberOfInstallments
          in: query
          schema:
            type: integer
            enum: [6, 9, 12, 24]
        - name: isPaid
          in: query
          schema:
            type: boolean

  /api/v1/loans/{loanId}/installments:
    get:
      summary: List installments for a loan
      security:
        - bearerAuth: []

  /api/v1/loans/{loanId}/payments:
    post:
      summary: Process payment for a loan
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PaymentRequest'
```

### 8. Event-Driven Architecture with SAGA Pattern

Implement domain events with event sourcing capabilities and SAGA orchestration for distributed transactions:

#### Domain Events

```java
// Customer Management Events
- CustomerCreated
- CreditLimitUpdated
- CreditReserved
- CreditReservationFailed
- CreditReleased

// Loan Origination Events
- LoanApplicationSubmitted
- LoanApproved
- LoanRejected
- LoanCreated
- InstallmentScheduleGenerated

// Payment Processing Events
- PaymentInitiated
- PaymentValidated
- InstallmentPaid
- EarlyPaymentDiscountApplied
- LatePaymentPenaltyApplied
- PaymentCompleted
- PaymentFailed
- LoanFullyPaid
```

#### SAGA Implementations

##### 1. Loan Creation SAGA

Orchestrates the distributed transaction for creating a loan across multiple services:

```java
@Saga
public class LoanCreationSaga {

    @StartSaga
    @SagaOrchestrationStart
    public void handle(LoanApplicationSubmitted event) {
        // Step 1: Validate customer exists
        commandGateway.send(new ValidateCustomerCommand(event.getCustomerId()));
    }

    @SagaOrchestrationStep
    public void handle(CustomerValidated event) {
        // Step 2: Check and reserve credit
        commandGateway.send(new ReserveCreditCommand(
            event.getCustomerId(),
            event.getRequestedAmount()
        ));
    }

    @SagaOrchestrationStep
    public void handle(CreditReserved event) {
        // Step 3: Create loan
        commandGateway.send(new CreateLoanCommand(
            event.getCustomerId(),
            event.getAmount(),
            event.getInterestRate(),
            event.getInstallments()
        ));
    }

    @SagaOrchestrationStep
    public void handle(LoanCreated event) {
        // Step 4: Generate installment schedule
        commandGateway.send(new GenerateInstallmentScheduleCommand(event.getLoanId()));
    }

    @EndSaga
    @SagaOrchestrationEnd
    public void handle(InstallmentScheduleGenerated event) {
        // Saga completed successfully
        commandGateway.send(new NotifyLoanCreationSuccessCommand(event.getLoanId()));
    }

    // Compensating transactions
    @SagaOrchestrationStep
    public void handle(CreditReservationFailed event) {
        // Compensation: Cancel loan application
        commandGateway.send(new CancelLoanApplicationCommand(event.getApplicationId()));
    }

    @SagaOrchestrationStep
    public void handle(LoanCreationFailed event) {
        // Compensation: Release reserved credit
        commandGateway.send(new ReleaseCreditCommand(
            event.getCustomerId(),
            event.getAmount()
        ));
    }
}
```

##### 2. Payment Processing SAGA

Handles the complex payment flow with potential multiple installments:

```java
@Saga
public class PaymentProcessingSaga {

    private PaymentContext paymentContext;

    @StartSaga
    @SagaOrchestrationStart
    public void handle(PaymentInitiated event) {
        paymentContext = new PaymentContext(event);
        // Step 1: Validate payment amount
        commandGateway.send(new ValidatePaymentCommand(
            event.getLoanId(),
            event.getAmount()
        ));
    }

    @SagaOrchestrationStep
    public void handle(PaymentValidated event) {
        // Step 2: Calculate applicable installments
        commandGateway.send(new CalculatePayableInstallmentsCommand(
            event.getLoanId(),
            event.getAmount(),
            event.getPaymentDate()
        ));
    }

    @SagaOrchestrationStep
    public void handle(PayableInstallmentsCalculated event) {
        paymentContext.setInstallmentsToPay(event.getInstallments());
        // Step 3: Process each installment payment
        processNextInstallment();
    }

    private void processNextInstallment() {
        if (paymentContext.hasMoreInstallments()) {
            InstallmentPaymentDetails next = paymentContext.getNextInstallment();
            commandGateway.send(new PayInstallmentCommand(
                next.getInstallmentId(),
                next.getPaymentAmount(),
                next.getPaymentDate()
            ));
        } else {
            // All installments processed
            commandGateway.send(new CompletePaymentCommand(
                paymentContext.getPaymentId(),
                paymentContext.getTotalPaid()
            ));
        }
    }

    @SagaOrchestrationStep
    public void handle(InstallmentPaid event) {
        paymentContext.recordInstallmentPayment(event);

        // Check if discount or penalty was applied
        if (event.hasDiscount()) {
            commandGateway.send(new RecordDiscountCommand(event));
        } else if (event.hasPenalty()) {
            commandGateway.send(new RecordPenaltyCommand(event));
        }

        // Process next installment
        processNextInstallment();
    }

    @SagaOrchestrationStep
    public void handle(PaymentCompleted event) {
        // Step 4: Check if loan is fully paid
        commandGateway.send(new CheckLoanStatusCommand(event.getLoanId()));
    }

    @SagaOrchestrationStep
    public void handle(LoanFullyPaid event) {
        // Step 5: Release customer credit
        commandGateway.send(new ReleaseCreditCommand(
            event.getCustomerId(),
            event.getPrincipalAmount()
        ));
    }

    @EndSaga
    @SagaOrchestrationEnd
    public void handle(CreditReleased event) {
        // Saga completed successfully
        commandGateway.send(new NotifyPaymentSuccessCommand(
            paymentContext.getPaymentId()
        ));
    }

    // Error handling
    @SagaOrchestrationStep
    public void handle(PaymentFailed event) {
        // Rollback any partial payments
        commandGateway.send(new RollbackPaymentCommand(
            paymentContext.getPaymentId(),
            paymentContext.getPaidInstallments()
        ));
    }
}
```

##### 3. Credit Limit Update SAGA

Manages credit limit changes with impact on existing loans:

```java
@Saga
public class CreditLimitUpdateSaga {

    @StartSaga
    @SagaOrchestrationStart
    public void handle(CreditLimitUpdateRequested event) {
        // Step 1: Validate new credit limit
        commandGateway.send(new ValidateCreditLimitCommand(
            event.getCustomerId(),
            event.getNewLimit()
        ));
    }

    @SagaOrchestrationStep
    public void handle(CreditLimitValidated event) {
        // Step 2: Check impact on existing loans
        commandGateway.send(new CheckExistingLoansCommand(
            event.getCustomerId(),
            event.getNewLimit()
        ));
    }

    @SagaOrchestrationStep
    public void handle(ExistingLoansChecked event) {
        if (event.isCompatible()) {
            // Step 3: Update credit limit
            commandGateway.send(new UpdateCreditLimitCommand(
                event.getCustomerId(),
                event.getNewLimit()
            ));
        } else {
            // Cannot reduce limit below used amount
            commandGateway.send(new RejectCreditLimitUpdateCommand(
                event.getCustomerId(),
                "Credit limit cannot be less than currently used credit"
            ));
        }
    }

    @EndSaga
    @SagaOrchestrationEnd
    public void handle(CreditLimitUpdated event) {
        // Notify relevant systems
        commandGateway.send(new NotifyCreditLimitChangeCommand(event));
    }
}
```

#### SAGA Infrastructure Configuration

```java
@Configuration
public class SagaConfiguration {

    @Bean
    public SagaStore sagaStore(EntityManagerFactory entityManagerFactory) {
        return JpaSagaStore.builder()
            .entityManagerFactory(entityManagerFactory)
            .build();
    }

    @Bean
    public SagaManager<LoanCreationSaga> loanCreationSagaManager(
            SagaStore sagaStore,
            EventBus eventBus) {
        return SagaManager.builder()
            .sagaType(LoanCreationSaga.class)
            .sagaStore(sagaStore)
            .eventBus(eventBus)
            .build();
    }

    @Bean
    public DeadlineManager deadlineManager(
            TransactionManager transactionManager,
            ScheduledExecutorService executorService) {
        return SimpleDeadlineManager.builder()
            .transactionManager(transactionManager)
            .executorService(executorService)
            .build();
    }
}
```

#### Event Store Configuration

```java
// Event Store Implementation
@Entity
@Table(name = "domain_event_entry")
public class DomainEventEntry {
    @Id
    private String eventIdentifier;
    private String aggregateIdentifier;
    private Long sequenceNumber;
    private String payloadType;

    @Lob
    private byte[] payload;

    @Lob
    private byte[] metaData;

    private Instant timestamp;

    // Event replay support
    @Index
    private String sagaIdentifier;

    @Index
    private String sagaType;
}

// Event Sourcing Configuration
@Configuration
public class EventSourcingConfiguration {

    @Bean
    public EventStore eventStore(
            EntityManagerFactory entityManagerFactory,
            TransactionManager transactionManager) {
        return EmbeddedEventStore.builder()
            .storageEngine(
                JpaEventStorageEngine.builder()
                    .entityManagerFactory(entityManagerFactory)
                    .transactionManager(transactionManager)
                    .build()
            )
            .build();
    }

    @Bean
    public SnapshotTriggerDefinition snapshotTriggerDefinition(
            EventStore eventStore) {
        return new EventCountSnapshotTriggerDefinition(eventStore, 100);
    }
}
```

### 9. Testing Strategy

Implement comprehensive testing including SAGA testing:

```java
// Unit Tests
- Domain model tests (Aggregates, Value Objects, Domain Services)
- Use case tests with mocked dependencies
- Domain event tests

// Integration Tests
- Repository tests with @DataJpaTest
- Web layer tests with @WebMvcTest
- Event handling tests with @SpringBootTest
- SAGA flow tests with test fixtures

// SAGA Testing
@Test
class LoanCreationSagaTest {

    @Test
    void shouldCompleteLoanCreationSuccessfully() {
        // Given
        fixture.givenNoPriorActivity()
            // When
            .whenPublishingA(new LoanApplicationSubmitted(customerId, amount))
            // Then
            .expectActiveSagas(1)
            .expectDispatchedCommands(
                new ValidateCustomerCommand(customerId),
                new ReserveCreditCommand(customerId, amount),
                new CreateLoanCommand(customerId, amount, rate, installments),
                new GenerateInstallmentScheduleCommand(loanId)
            )
            .expectPublishedEvents(
                new CustomerValidated(customerId),
                new CreditReserved(customerId, amount),
                new LoanCreated(loanId),
                new InstallmentScheduleGenerated(loanId)
            );
    }

    @Test
    void shouldCompensateOnCreditReservationFailure() {
        // Test compensation logic
    }
}

// Architecture Tests
@Test
void domainShouldNotDependOnInfrastructure() {
    noClasses()
        .that().resideInAPackage("..domain..")
        .should().dependOnClassesThat()
        .resideInAPackage("..infrastructure..")
        .check(classes);
}

// Contract Tests
- API contract tests with Spring Cloud Contract
- Event contract tests

// End-to-End Tests
- Complete user journey tests
- Performance tests with Gatling
```

### 10. Documentation Requirements

Provide comprehensive documentation:

1. **README.md** - Project overview, setup instructions
2. **ARCHITECTURE.md** - Detailed architecture decisions including SAGA patterns
3. **API.md** - API documentation with examples
4. **DOMAIN.md** - Domain model documentation
5. **SAGAS.md** - SAGA flows and compensation strategies
6. **EVENTS.md** - Event catalog and schemas
7. **DEPLOYMENT.md** - Deployment instructions for different environments
8. **CONTRIBUTING.md** - Development guidelines
9. **TROUBLESHOOTING.md** - Common issues and solutions

### 11. Observability Requirements

Implement the four golden signals with SAGA-specific monitoring:

1. **Latency** - Track response times for all operations and SAGA execution times
2. **Traffic** - Monitor requests per second and events processed
3. **Errors** - Track error rates, compensation rates, and SAGA failures
4. **Saturation** - Monitor resource utilization and event store growth

Include:
- Custom metrics for business operations (loans created, payments processed)
- SAGA execution metrics (completion time, compensation rate)
- Distributed tracing for request flows and SAGA steps
- Structured logging with correlation IDs and SAGA IDs
- Real-time dashboards for SAGA monitoring
- Alerting rules for SLO violations and stuck SAGAs

### 12. Security Requirements

Implement defense in depth:

#### 1. Authentication & Authorization
- OAuth 2.0 with JWT tokens
- Role-based access control (RBAC)
- API key management for service-to-service communication

#### 2. Data Protection
- Encrypt sensitive data at rest
- Use TLS 1.3 for data in transit
- Implement field-level encryption for PII
- Secure event payloads in event store

#### 3. API Security
- Input validation and sanitization
- SQL injection prevention
- Rate limiting and throttling
- CORS configuration

#### 4. Audit & Compliance
- Comprehensive audit logging
- Event sourcing for complete audit trail
- Data retention policies
- GDPR compliance for customer data
- Regular security scanning

## Implementation Guidelines

Please implement this complete system following all the specified requirements, ensuring production-readiness, maintainability, and scalability. The implementation should demonstrate best practices in:

- Domain-driven design
- Clean architecture
- Event-driven architecture with SAGA pattern
- Cloud-native development
- Microservices patterns
- DevOps practices

The system should be ready for deployment in a production banking environment with all necessary security, compliance, and operational considerations addressed.
