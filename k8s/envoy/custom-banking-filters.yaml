# Custom Banking Protocol Filters for Enterprise Loan Management System
# Enhanced Audit Trails and Banking Compliance Enforcement

apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: banking-protocol-filters
  namespace: banking-system
  labels:
    app: banking-system
    version: v1
    compliance: fapi-2.0
spec:
  configPatches:
  # Banking Transaction Validation Filter
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.wasm
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
          config:
            name: "banking_transaction_validator"
            vm_config:
              vm_id: "banking_transaction_validator"
              runtime: "envoy.wasm.runtime.v8"
              code:
                local:
                  inline_string: |
                    const BANKING_PROTOCOLS = {
                      SWIFT: 'swift',
                      SEPA: 'sepa', 
                      FASTER_PAYMENTS: 'faster-payments',
                      ACH: 'ach',
                      WIRE: 'wire',
                      OPEN_BANKING: 'open-banking'
                    };

                    const REGULATORY_REQUIREMENTS = {
                      PCI_DSS: ['card-payment', 'pci-validation'],
                      GDPR: ['customer-data', 'consent-management'],
                      SOX: ['financial-reporting', 'audit-trail'],
                      FAPI: ['oauth2', 'jwt-validation', 'mtls']
                    };

                    class BankingTransactionValidator {
                      constructor(rootContext) {
                        this.rootContext = rootContext;
                        this.transactionCount = 0;
                        this.auditBuffer = [];
                      }

                      onRequestHeaders() {
                        const headers = this.getRequestHeaders();
                        const path = headers[':path'];
                        const method = headers[':method'];
                        const contentType = headers['content-type'];
                        
                        // Extract banking protocol from request
                        const protocol = this.detectBankingProtocol(path, headers);
                        
                        // Validate banking transaction format
                        const validationResult = this.validateBankingTransaction(protocol, headers);
                        
                        if (!validationResult.valid) {
                          this.log(LogLevel.error, `Banking transaction validation failed: ${validationResult.reason}`);
                          this.sendLocalResponse(400, 
                            JSON.stringify({
                              error: 'BANKING_VALIDATION_FAILED',
                              code: 'BVF001',
                              message: validationResult.reason,
                              protocol: protocol,
                              timestamp: new Date().toISOString(),
                              transactionId: this.generateTransactionId()
                            }), 
                            { 'content-type': 'application/json' }
                          );
                          return FilterHeadersStatus.StopIteration;
                        }

                        // Add banking-specific headers
                        this.addBankingHeaders(protocol, headers);
                        
                        // Log banking transaction start
                        this.auditBankingTransaction('REQUEST', protocol, headers);
                        
                        return FilterHeadersStatus.Continue;
                      }

                      onResponseHeaders() {
                        const responseHeaders = this.getResponseHeaders();
                        const requestHeaders = this.getRequestHeaders();
                        const protocol = this.detectBankingProtocol(requestHeaders[':path'], requestHeaders);
                        
                        // Add response audit headers
                        this.addResponseAuditHeaders(responseHeaders);
                        
                        // Log banking transaction completion
                        this.auditBankingTransaction('RESPONSE', protocol, responseHeaders);
                        
                        return FilterHeadersStatus.Continue;
                      }

                      detectBankingProtocol(path, headers) {
                        if (path.includes('/open-banking/')) return BANKING_PROTOCOLS.OPEN_BANKING;
                        if (path.includes('/swift/')) return BANKING_PROTOCOLS.SWIFT;
                        if (path.includes('/sepa/')) return BANKING_PROTOCOLS.SEPA;
                        if (path.includes('/faster-payments/')) return BANKING_PROTOCOLS.FASTER_PAYMENTS;
                        if (path.includes('/ach/')) return BANKING_PROTOCOLS.ACH;
                        if (path.includes('/wire/')) return BANKING_PROTOCOLS.WIRE;
                        
                        // Check headers for protocol indicators
                        const messageType = headers['x-banking-message-type'];
                        if (messageType) {
                          if (messageType.includes('MT')) return BANKING_PROTOCOLS.SWIFT;
                          if (messageType.includes('pain.')) return BANKING_PROTOCOLS.SEPA;
                        }
                        
                        return 'generic';
                      }

                      validateBankingTransaction(protocol, headers) {
                        const transactionId = headers['x-transaction-id'] || headers['x-fapi-interaction-id'];
                        const customerId = headers['x-customer-id'];
                        const institutionId = headers['x-institution-id'];
                        
                        // Basic validation
                        if (!transactionId) {
                          return { valid: false, reason: 'Missing transaction ID' };
                        }
                        
                        if (!this.isValidTransactionId(transactionId)) {
                          return { valid: false, reason: 'Invalid transaction ID format' };
                        }

                        // Protocol-specific validation
                        switch (protocol) {
                          case BANKING_PROTOCOLS.OPEN_BANKING:
                            return this.validateOpenBankingTransaction(headers);
                          case BANKING_PROTOCOLS.SWIFT:
                            return this.validateSwiftTransaction(headers);
                          case BANKING_PROTOCOLS.SEPA:
                            return this.validateSepaTransaction(headers);
                          default:
                            return this.validateGenericBankingTransaction(headers);
                        }
                      }

                      validateOpenBankingTransaction(headers) {
                        const interactionId = headers['x-fapi-interaction-id'];
                        const clientId = headers['x-fapi-client-id'];
                        const authDate = headers['x-fapi-auth-date'];
                        
                        if (!interactionId || !this.isValidUUID(interactionId)) {
                          return { valid: false, reason: 'Invalid or missing FAPI interaction ID' };
                        }
                        
                        if (!clientId) {
                          return { valid: false, reason: 'Missing FAPI client ID' };
                        }
                        
                        return { valid: true };
                      }

                      validateSwiftTransaction(headers) {
                        const messageType = headers['x-swift-message-type'];
                        const senderBIC = headers['x-swift-sender-bic'];
                        const receiverBIC = headers['x-swift-receiver-bic'];
                        
                        if (!messageType || !messageType.match(/^MT\d{3}$/)) {
                          return { valid: false, reason: 'Invalid SWIFT message type' };
                        }
                        
                        if (!senderBIC || !this.isValidBIC(senderBIC)) {
                          return { valid: false, reason: 'Invalid sender BIC' };
                        }
                        
                        if (!receiverBIC || !this.isValidBIC(receiverBIC)) {
                          return { valid: false, reason: 'Invalid receiver BIC' };
                        }
                        
                        return { valid: true };
                      }

                      validateSepaTransaction(headers) {
                        const messageId = headers['x-sepa-message-id'];
                        const endToEndId = headers['x-sepa-end-to-end-id'];
                        const instructionId = headers['x-sepa-instruction-id'];
                        
                        if (!messageId || messageId.length > 35) {
                          return { valid: false, reason: 'Invalid SEPA message ID' };
                        }
                        
                        if (!endToEndId || endToEndId.length > 35) {
                          return { valid: false, reason: 'Invalid SEPA end-to-end ID' };
                        }
                        
                        return { valid: true };
                      }

                      validateGenericBankingTransaction(headers) {
                        // Generic banking validation rules
                        const amount = headers['x-transaction-amount'];
                        const currency = headers['x-transaction-currency'];
                        
                        if (amount && !this.isValidAmount(amount)) {
                          return { valid: false, reason: 'Invalid transaction amount format' };
                        }
                        
                        if (currency && !this.isValidCurrency(currency)) {
                          return { valid: false, reason: 'Invalid currency code' };
                        }
                        
                        return { valid: true };
                      }

                      addBankingHeaders(protocol, headers) {
                        const transactionId = headers['x-transaction-id'] || this.generateTransactionId();
                        const timestamp = new Date().toISOString();
                        
                        // Add common banking headers
                        this.replaceRequestHeader('x-banking-protocol', protocol);
                        this.replaceRequestHeader('x-banking-timestamp', timestamp);
                        this.replaceRequestHeader('x-banking-audit-id', this.generateAuditId());
                        this.replaceRequestHeader('x-banking-compliance-level', this.determineComplianceLevel(protocol));
                        
                        // Add regulatory tracking headers
                        this.replaceRequestHeader('x-regulatory-jurisdiction', this.determineJurisdiction(headers));
                        this.replaceRequestHeader('x-data-classification', 'restricted');
                        this.replaceRequestHeader('x-audit-required', 'true');
                        
                        // Add protocol-specific headers
                        if (protocol === BANKING_PROTOCOLS.OPEN_BANKING) {
                          this.addOpenBankingHeaders(headers);
                        }
                      }

                      addOpenBankingHeaders(headers) {
                        // Ensure FAPI required headers are present
                        if (!headers['x-fapi-interaction-id']) {
                          this.replaceRequestHeader('x-fapi-interaction-id', this.generateUUID());
                        }
                        
                        this.replaceRequestHeader('x-fapi-auth-date', new Date().toISOString());
                        this.replaceRequestHeader('x-fapi-customer-ip-address', this.getDownstreamRemoteAddress());
                      }

                      addResponseAuditHeaders(responseHeaders) {
                        const auditId = this.getRequestHeader('x-banking-audit-id');
                        const timestamp = new Date().toISOString();
                        
                        this.addResponseHeader('x-banking-response-timestamp', timestamp);
                        this.addResponseHeader('x-banking-audit-id', auditId);
                        this.addResponseHeader('x-banking-processed', 'true');
                        this.addResponseHeader('x-regulatory-compliance', 'verified');
                      }

                      auditBankingTransaction(phase, protocol, headers) {
                        const auditEvent = {
                          timestamp: new Date().toISOString(),
                          phase: phase,
                          protocol: protocol,
                          transactionId: headers['x-transaction-id'] || this.getRequestHeader('x-transaction-id'),
                          auditId: this.getRequestHeader('x-banking-audit-id'),
                          customerId: headers['x-customer-id'],
                          institutionId: headers['x-institution-id'],
                          path: this.getRequestHeader(':path'),
                          method: this.getRequestHeader(':method'),
                          sourceIP: this.getDownstreamRemoteAddress(),
                          userAgent: headers['user-agent'],
                          compliance: this.getRequestHeader('x-banking-compliance-level'),
                          jurisdiction: this.getRequestHeader('x-regulatory-jurisdiction')
                        };

                        this.auditBuffer.push(auditEvent);
                        this.log(LogLevel.info, `Banking Transaction Audit: ${JSON.stringify(auditEvent)}`);
                        
                        // Flush audit buffer if it gets too large
                        if (this.auditBuffer.length > 100) {
                          this.flushAuditBuffer();
                        }
                      }

                      // Utility functions
                      isValidTransactionId(id) {
                        return /^[A-Za-z0-9_-]{8,64}$/.test(id);
                      }

                      isValidUUID(uuid) {
                        return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid);
                      }

                      isValidBIC(bic) {
                        return /^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$/.test(bic);
                      }

                      isValidAmount(amount) {
                        return /^\d+(\.\d{1,2})?$/.test(amount);
                      }

                      isValidCurrency(currency) {
                        const validCurrencies = ['USD', 'EUR', 'GBP', 'JPY', 'CHF', 'CAD', 'AUD', 'TRY'];
                        return validCurrencies.includes(currency);
                      }

                      generateTransactionId() {
                        return 'TXN_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                      }

                      generateAuditId() {
                        return 'AUDIT_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                      }

                      generateUUID() {
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                          const r = Math.random() * 16 | 0;
                          const v = c == 'x' ? r : (r & 0x3 | 0x8);
                          return v.toString(16);
                        });
                      }

                      determineComplianceLevel(protocol) {
                        if (protocol === BANKING_PROTOCOLS.OPEN_BANKING) return 'FAPI_HIGH';
                        if (protocol === BANKING_PROTOCOLS.SWIFT) return 'SWIFT_HIGH';
                        return 'STANDARD';
                      }

                      determineJurisdiction(headers) {
                        const countryCode = headers['x-customer-country'] || headers['cf-ipcountry'] || 'US';
                        return countryCode.toUpperCase();
                      }

                      flushAuditBuffer() {
                        // In a real implementation, this would send to an audit service
                        this.log(LogLevel.info, `Flushing ${this.auditBuffer.length} audit events`);
                        this.auditBuffer = [];
                      }
                    }

                    class BankingTransactionValidatorRootContext {
                      createFilter() {
                        return new BankingTransactionValidator(this);
                      }
                    }

                    // Export the filter
                    registerRootContext((rootContext) => new BankingTransactionValidatorRootContext(rootContext), "banking_transaction_validator");
            configuration:
              "@type": type.googleapis.com/google.protobuf.StringValue
              value: |
                {
                  "audit_endpoint": "http://audit-service.banking-system.svc.cluster.local:8080/audit",
                  "compliance_level": "high",
                  "buffer_size": 100
                }

  # Banking Message Format Validator Filter
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inline_code: |
            -- Banking Message Format Validator
            -- Validates ISO 20022, SWIFT MT, and Open Banking message formats

            local json = require("json")
            local string = require("string")

            -- Message format validators
            local validators = {}

            -- ISO 20022 XML message validator
            function validators.validate_iso20022(body)
              if not body then return false, "Empty message body" end
              
              -- Check for XML structure
              if not string.match(body, "^%s*<%?xml") then
                return false, "Not a valid XML message"
              end
              
              -- Check for ISO 20022 namespace
              if not string.match(body, "urn:iso:std:iso:20022:") then
                return false, "Missing ISO 20022 namespace"
              end
              
              -- Check for document type
              local doc_types = {
                "pain%.001%.001%.%d+",  -- CustomerCreditTransferInitiation
                "pain%.002%.001%.%d+",  -- CustomerPaymentStatusReport
                "pain%.008%.001%.%d+",  -- CustomerDirectDebitInitiation
                "pacs%.008%.001%.%d+",  -- CustomerCreditTransferInitiation
                "camt%.053%.001%.%d+",  -- BankToCustomerStatement
                "camt%.054%.001%.%d+"   -- BankToCustomerDebitCreditNotification
              }
              
              for _, pattern in ipairs(doc_types) do
                if string.match(body, pattern) then
                  return true, "Valid ISO 20022 message"
                end
              end
              
              return false, "Unknown ISO 20022 message type"
            end

            -- SWIFT MT message validator
            function validators.validate_swift_mt(body)
              if not body then return false, "Empty message body" end
              
              -- Check basic SWIFT MT format
              if not string.match(body, "^%s*{1:") then
                return false, "Invalid SWIFT MT format - missing basic header"
              end
              
              -- Extract message type
              local mt_type = string.match(body, "{2:[A-Z]?(%d%d%d)[A-Z]?")
              if not mt_type then
                return false, "Cannot determine SWIFT MT message type"
              end
              
              -- Validate common MT message types
              local valid_types = {
                ["103"] = "Single Customer Credit Transfer",
                ["202"] = "General Financial Institution Transfer",
                ["950"] = "Statement Message",
                ["940"] = "Customer Statement Message",
                ["101"] = "Request for Transfer"
              }
              
              if valid_types[mt_type] then
                return true, "Valid SWIFT MT" .. mt_type .. " message"
              else
                return false, "Unsupported SWIFT MT message type: " .. mt_type
              end
            end

            -- Open Banking JSON message validator
            function validators.validate_open_banking(body, path)
              if not body then return false, "Empty message body" end
              
              local success, parsed = pcall(json.decode, body)
              if not success then
                return false, "Invalid JSON format"
              end
              
              -- Check for Open Banking v3.1 structure
              if string.match(path, "/open%-banking/v3%.1/aisp/") then
                return validators.validate_aisp_message(parsed)
              elseif string.match(path, "/open%-banking/v3%.1/pisp/") then
                return validators.validate_pisp_message(parsed)
              elseif string.match(path, "/open%-banking/v3%.1/cbpii/") then
                return validators.validate_cbpii_message(parsed)
              end
              
              return false, "Unknown Open Banking endpoint"
            end

            -- AISP message validator
            function validators.validate_aisp_message(parsed)
              if parsed.Data and parsed.Data.Account then
                return true, "Valid AISP account message"
              elseif parsed.Data and parsed.Data.Balance then
                return true, "Valid AISP balance message"
              elseif parsed.Data and parsed.Data.Transaction then
                return true, "Valid AISP transaction message"
              end
              return false, "Invalid AISP message structure"
            end

            -- PISP message validator  
            function validators.validate_pisp_message(parsed)
              if parsed.Data and parsed.Data.Initiation then
                if parsed.Data.Initiation.InstructedAmount and 
                   parsed.Data.Initiation.CreditorAccount then
                  return true, "Valid PISP payment initiation message"
                end
              elseif parsed.Data and parsed.Data.Status then
                return true, "Valid PISP payment status message"
              end
              return false, "Invalid PISP message structure"
            end

            -- CBPII message validator
            function validators.validate_cbpii_message(parsed)
              if parsed.Data and parsed.Data.FundsAvailable then
                return true, "Valid CBPII funds confirmation message"
              end
              return false, "Invalid CBPII message structure"
            end

            -- Main request validation function
            function envoy_on_request(request_handle)
              local headers = request_handle:headers()
              local path = headers:get(":path")
              local method = headers:get(":method")
              local content_type = headers:get("content-type")
              
              -- Only validate POST and PUT requests with body
              if method ~= "POST" and method ~= "PUT" then
                return
              end
              
              local body = request_handle:body()
              if not body then
                return
              end
              
              local body_string = tostring(body:getBytes(0, body:length()))
              local is_valid = false
              local error_message = ""
              
              -- Determine message format and validate
              if string.match(path, "/open%-banking/") then
                is_valid, error_message = validators.validate_open_banking(body_string, path)
              elseif content_type and string.match(content_type, "application/xml") then
                is_valid, error_message = validators.validate_iso20022(body_string)
              elseif content_type and string.match(content_type, "text/plain") then
                is_valid, error_message = validators.validate_swift_mt(body_string)
              else
                -- Default to Open Banking for JSON
                if content_type and string.match(content_type, "application/json") then
                  is_valid, error_message = validators.validate_open_banking(body_string, path)
                else
                  -- Skip validation for unknown content types
                  return
                end
              end
              
              -- Log validation result
              local audit_data = {
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                transaction_id = headers:get("x-transaction-id") or "unknown",
                path = path,
                method = method,
                content_type = content_type,
                validation_result = is_valid,
                error_message = error_message,
                source_ip = request_handle:connection():remoteAddress()
              }
              
              request_handle:logInfo("Banking Message Validation: " .. json.encode(audit_data))
              
              -- Reject invalid messages
              if not is_valid then
                local error_response = json.encode({
                  error = "INVALID_MESSAGE_FORMAT",
                  code = "IMF001", 
                  message = error_message,
                  timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                  transaction_id = headers:get("x-transaction-id") or "unknown"
                })
                
                request_handle:respond(
                  {[":status"] = "400", ["content-type"] = "application/json"},
                  error_response
                )
                return
              end
              
              -- Add validation headers
              request_handle:headers():add("x-message-format-validated", "true")
              request_handle:headers():add("x-validation-timestamp", os.date("!%Y-%m-%dT%H:%M:%SZ"))
              request_handle:headers():add("x-validation-result", error_message)
            end

  # Banking Regulatory Compliance Filter
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inline_code: |
            -- Banking Regulatory Compliance Filter
            -- Enforces PCI DSS, GDPR, SOX, and FAPI compliance requirements

            local json = require("json")
            local string = require("string")

            -- Compliance validators
            local compliance = {}

            -- PCI DSS compliance check
            function compliance.check_pci_dss(headers, path)
              local violations = {}
              
              -- Check for card data endpoints
              if string.match(path, "/cards/") or string.match(path, "/payment%-cards/") then
                -- Ensure encryption headers
                if not headers:get("x-encrypted-data") then
                  table.insert(violations, "Card data must be encrypted (PCI DSS 3.4)")
                end
                
                -- Ensure no card data in URL
                if string.match(path, "%d%d%d%d%-%d%d%d%d%-%d%d%d%d%-%d%d%d%d") then
                  table.insert(violations, "Card numbers not allowed in URL (PCI DSS 3.4)")
                end
              end
              
              return violations
            end

            -- GDPR compliance check
            function compliance.check_gdpr(headers, path)
              local violations = {}
              local customer_country = headers:get("x-customer-country")
              
              -- Check for EU customer data processing
              if customer_country and (customer_country == "EU" or 
                 customer_country == "DE" or customer_country == "FR" or 
                 customer_country == "IT" or customer_country == "ES") then
                
                -- Ensure consent header
                if not headers:get("x-customer-consent") then
                  table.insert(violations, "GDPR consent required for EU customer data processing")
                end
                
                -- Ensure data processing purpose
                if not headers:get("x-processing-purpose") then
                  table.insert(violations, "GDPR requires explicit data processing purpose")
                end
                
                -- Check for personal data in path
                if string.match(path, "/personal%-data/") or string.match(path, "/customer%-details/") then
                  if not headers:get("x-lawful-basis") then
                    table.insert(violations, "GDPR lawful basis required for personal data processing")
                  end
                end
              end
              
              return violations
            end

            -- SOX compliance check
            function compliance.check_sox(headers, path)
              local violations = {}
              
              -- Check for financial reporting endpoints
              if string.match(path, "/financial%-reports/") or 
                 string.match(path, "/accounting/") or
                 string.match(path, "/audit%-trail/") then
                
                -- Ensure user identification
                if not headers:get("x-user-id") then
                  table.insert(violations, "SOX requires user identification for financial operations")
                end
                
                -- Ensure audit trail
                if not headers:get("x-audit-required") then
                  table.insert(violations, "SOX requires audit trail for financial operations")
                end
                
                -- Ensure segregation of duties
                if headers:get("x-user-role") == "both-maker-checker" then
                  table.insert(violations, "SOX prohibits same user as both maker and checker")
                end
              end
              
              return violations
            end

            -- FAPI compliance check
            function compliance.check_fapi(headers, path)
              local violations = {}
              
              -- Check for Open Banking endpoints
              if string.match(path, "/open%-banking/") then
                -- FAPI interaction ID required
                if not headers:get("x-fapi-interaction-id") then
                  table.insert(violations, "FAPI interaction ID required for Open Banking operations")
                end
                
                -- FAPI auth date required
                if not headers:get("x-fapi-auth-date") then
                  table.insert(violations, "FAPI auth date required for Open Banking operations")
                end
                
                -- FAPI customer IP required
                if not headers:get("x-fapi-customer-ip-address") then
                  table.insert(violations, "FAPI customer IP address required for Open Banking operations")
                end
                
                -- Check authorization header format
                local auth_header = headers:get("authorization")
                if auth_header and not string.match(auth_header, "^Bearer ") then
                  table.insert(violations, "FAPI requires Bearer token authorization")
                end
              end
              
              return violations
            end

            -- Data classification enforcement
            function compliance.enforce_data_classification(headers, path)
              local violations = {}
              local data_classification = headers:get("x-data-classification")
              
              if not data_classification then
                table.insert(violations, "Data classification header required")
                return violations
              end
              
              -- Enforce classification-specific rules
              if data_classification == "restricted" then
                if not headers:get("x-encryption-level") then
                  table.insert(violations, "Restricted data requires encryption level header")
                end
                
                if not headers:get("x-access-control") then
                  table.insert(violations, "Restricted data requires access control verification")
                end
              elseif data_classification == "confidential" then
                if not headers:get("x-user-clearance") then
                  table.insert(violations, "Confidential data requires user clearance verification")
                end
              end
              
              return violations
            end

            -- Generate compliance audit event
            function compliance.generate_audit_event(headers, path, violations)
              local audit_event = {
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                event_type = "compliance_check",
                transaction_id = headers:get("x-transaction-id") or "unknown",
                audit_id = headers:get("x-banking-audit-id") or "unknown", 
                path = path,
                method = headers:get(":method"),
                customer_id = headers:get("x-customer-id"),
                user_id = headers:get("x-user-id"),
                institution_id = headers:get("x-institution-id"),
                compliance_frameworks = {"PCI_DSS", "GDPR", "SOX", "FAPI"},
                violations = violations,
                violation_count = #violations,
                compliance_status = #violations == 0 and "COMPLIANT" or "VIOLATIONS_DETECTED",
                source_ip = headers:get("x-forwarded-for") or "unknown",
                user_agent = headers:get("user-agent"),
                data_classification = headers:get("x-data-classification"),
                processing_purpose = headers:get("x-processing-purpose"),
                regulatory_jurisdiction = headers:get("x-regulatory-jurisdiction")
              }
              
              return audit_event
            end

            -- Main compliance validation function
            function envoy_on_request(request_handle)
              local headers = request_handle:headers()
              local path = headers:get(":path")
              local method = headers:get(":method")
              
              local all_violations = {}
              
              -- Run all compliance checks
              local pci_violations = compliance.check_pci_dss(headers, path)
              local gdpr_violations = compliance.check_gdpr(headers, path)
              local sox_violations = compliance.check_sox(headers, path)
              local fapi_violations = compliance.check_fapi(headers, path)
              local classification_violations = compliance.enforce_data_classification(headers, path)
              
              -- Combine all violations
              for _, violation in ipairs(pci_violations) do
                table.insert(all_violations, {framework = "PCI_DSS", violation = violation})
              end
              for _, violation in ipairs(gdpr_violations) do
                table.insert(all_violations, {framework = "GDPR", violation = violation})
              end
              for _, violation in ipairs(sox_violations) do
                table.insert(all_violations, {framework = "SOX", violation = violation})
              end
              for _, violation in ipairs(fapi_violations) do
                table.insert(all_violations, {framework = "FAPI", violation = violation})
              end
              for _, violation in ipairs(classification_violations) do
                table.insert(all_violations, {framework = "DATA_CLASSIFICATION", violation = violation})
              end
              
              -- Generate compliance audit event
              local audit_event = compliance.generate_audit_event(headers, path, all_violations)
              request_handle:logInfo("Banking Compliance Audit: " .. json.encode(audit_event))
              
              -- Block request if there are violations
              if #all_violations > 0 then
                local error_response = json.encode({
                  error = "COMPLIANCE_VIOLATION",
                  code = "CV001",
                  message = "Request violates regulatory compliance requirements",
                  violations = all_violations,
                  timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
                  transaction_id = headers:get("x-transaction-id") or "unknown",
                  audit_id = headers:get("x-banking-audit-id") or "unknown"
                })
                
                request_handle:respond(
                  {[":status"] = "403", ["content-type"] = "application/json"},
                  error_response
                )
                return
              end
              
              -- Add compliance verification headers
              request_handle:headers():add("x-compliance-verified", "true")
              request_handle:headers():add("x-compliance-timestamp", os.date("!%Y-%m-%dT%H:%M:%SZ"))
              request_handle:headers():add("x-compliance-frameworks", "PCI_DSS,GDPR,SOX,FAPI")
            end

---
# Envoy Filter for Enhanced Audit Logging
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: banking-audit-logger
  namespace: banking-system
  labels:
    app: banking-system
    version: v1
    compliance: audit-trail
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.wasm
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
          config:
            name: "banking_audit_logger"
            vm_config:
              vm_id: "banking_audit_logger"
              runtime: "envoy.wasm.runtime.v8"
              code:
                local:
                  inline_string: |
                    class BankingAuditLogger {
                      constructor(rootContext) {
                        this.rootContext = rootContext;
                        this.requestStartTime = 0;
                        this.auditContext = {};
                      }

                      onRequestHeaders() {
                        this.requestStartTime = Date.now();
                        const headers = this.getRequestHeaders();
                        
                        // Build comprehensive audit context
                        this.auditContext = {
                          // Request identification
                          transactionId: headers['x-transaction-id'] || this.generateTransactionId(),
                          auditId: headers['x-banking-audit-id'] || this.generateAuditId(),
                          fapiInteractionId: headers['x-fapi-interaction-id'],
                          
                          // Request details
                          timestamp: new Date().toISOString(),
                          method: headers[':method'],
                          path: headers[':path'],
                          authority: headers[':authority'],
                          scheme: headers[':scheme'],
                          
                          // Client information
                          sourceIp: this.getDownstreamRemoteAddress(),
                          userAgent: headers['user-agent'],
                          clientId: headers['x-fapi-client-id'] || headers['x-client-id'],
                          
                          // Banking context
                          customerId: headers['x-customer-id'],
                          institutionId: headers['x-institution-id'],
                          userId: headers['x-user-id'],
                          bankingProtocol: headers['x-banking-protocol'],
                          
                          // Regulatory context
                          jurisdiction: headers['x-regulatory-jurisdiction'],
                          dataClassification: headers['x-data-classification'],
                          processingPurpose: headers['x-processing-purpose'],
                          complianceLevel: headers['x-banking-compliance-level'],
                          
                          // Security context
                          authorizationType: this.extractAuthType(headers['authorization']),
                          encryptionLevel: headers['x-encryption-level'],
                          accessControl: headers['x-access-control'],
                          
                          // Content information
                          contentType: headers['content-type'],
                          contentLength: headers['content-length'],
                          acceptLanguage: headers['accept-language'],
                          
                          // Trace context
                          traceId: headers['x-trace-id'] || headers['x-b3-traceid'],
                          spanId: headers['x-span-id'] || headers['x-b3-spanid'],
                          
                          // Request phase
                          phase: 'REQUEST_START'
                        };
                        
                        // Log request initiation
                        this.logAuditEvent('BANKING_REQUEST_INITIATED', this.auditContext);
                        
                        return FilterHeadersStatus.Continue;
                      }

                      onRequestBody() {
                        const body = this.getRequestBody();
                        if (body) {
                          const bodyInfo = this.analyzeRequestBody(body);
                          this.auditContext.requestBodyAnalysis = bodyInfo;
                          
                          // Log sensitive data handling
                          if (bodyInfo.containsSensitiveData) {
                            this.logAuditEvent('SENSITIVE_DATA_PROCESSING', {
                              ...this.auditContext,
                              sensitiveDataTypes: bodyInfo.sensitiveDataTypes,
                              dataElements: bodyInfo.dataElements
                            });
                          }
                        }
                        
                        return FilterDataStatus.Continue;
                      }

                      onResponseHeaders() {
                        const responseHeaders = this.getResponseHeaders();
                        const processingTime = Date.now() - this.requestStartTime;
                        
                        // Update audit context with response information
                        this.auditContext.responseTimestamp = new Date().toISOString();
                        this.auditContext.processingTimeMs = processingTime;
                        this.auditContext.responseStatus = responseHeaders[':status'];
                        this.auditContext.responseHeaders = this.extractImportantResponseHeaders(responseHeaders);
                        this.auditContext.phase = 'RESPONSE_HEADERS';
                        
                        // Log response initiation
                        this.logAuditEvent('BANKING_RESPONSE_INITIATED', this.auditContext);
                        
                        return FilterHeadersStatus.Continue;
                      }

                      onResponseBody() {
                        const body = this.getResponseBody();
                        if (body) {
                          const bodyInfo = this.analyzeResponseBody(body);
                          this.auditContext.responseBodyAnalysis = bodyInfo;
                        }
                        
                        return FilterDataStatus.Continue;
                      }

                      onRequestComplete() {
                        const totalProcessingTime = Date.now() - this.requestStartTime;
                        
                        // Final audit context
                        const finalAuditContext = {
                          ...this.auditContext,
                          completionTimestamp: new Date().toISOString(),
                          totalProcessingTimeMs: totalProcessingTime,
                          phase: 'REQUEST_COMPLETE'
                        };
                        
                        // Determine audit event type based on status
                        const status = parseInt(this.auditContext.responseStatus);
                        let eventType = 'BANKING_REQUEST_COMPLETED';
                        
                        if (status >= 400 && status < 500) {
                          eventType = 'BANKING_REQUEST_CLIENT_ERROR';
                        } else if (status >= 500) {
                          eventType = 'BANKING_REQUEST_SERVER_ERROR';
                        }
                        
                        // Log final audit event
                        this.logAuditEvent(eventType, finalAuditContext);
                        
                        // Log performance metrics
                        this.logPerformanceMetrics(finalAuditContext);
                        
                        // Generate regulatory compliance report
                        this.generateComplianceReport(finalAuditContext);
                      }

                      analyzeRequestBody(body) {
                        const bodyStr = body.toString();
                        const analysis = {
                          size: bodyStr.length,
                          containsSensitiveData: false,
                          sensitiveDataTypes: [],
                          dataElements: {}
                        };
                        
                        // Check for sensitive data patterns
                        const patterns = {
                          creditCard: /\b\d{4}[\s\-]?\d{4}[\s\-]?\d{4}[\s\-]?\d{4}\b/g,
                          ssn: /\b\d{3}[\s\-]?\d{2}[\s\-]?\d{4}\b/g,
                          bankAccount: /\b\d{8,17}\b/g,
                          email: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g,
                          phone: /\b\+?[\d\s\-\(\)]{10,}\b/g
                        };
                        
                        for (const [type, pattern] of Object.entries(patterns)) {
                          const matches = bodyStr.match(pattern);
                          if (matches) {
                            analysis.containsSensitiveData = true;
                            analysis.sensitiveDataTypes.push(type);
                            analysis.dataElements[type] = matches.length;
                          }
                        }
                        
                        // Analyze JSON structure for banking data
                        try {
                          const parsed = JSON.parse(bodyStr);
                          analysis.jsonStructure = this.analyzeBankingJsonStructure(parsed);
                        } catch (e) {
                          // Not JSON or malformed
                        }
                        
                        return analysis;
                      }

                      analyzeResponseBody(body) {
                        const bodyStr = body.toString();
                        const analysis = {
                          size: bodyStr.length,
                          containsErrors: false,
                          errorCodes: [],
                          dataReturned: false
                        };
                        
                        // Check for error patterns
                        const errorPatterns = [
                          /error/i,
                          /exception/i,
                          /violation/i,
                          /"code":\s*"[A-Z]{3}\d{3}"/
                        ];
                        
                        for (const pattern of errorPatterns) {
                          if (pattern.test(bodyStr)) {
                            analysis.containsErrors = true;
                            break;
                          }
                        }
                        
                        // Check for banking data in response
                        if (bodyStr.includes('Data') && bodyStr.includes('Account')) {
                          analysis.dataReturned = true;
                          analysis.dataType = 'banking_account_data';
                        }
                        
                        return analysis;
                      }

                      analyzeBankingJsonStructure(json) {
                        const structure = {
                          hasData: !!json.Data,
                          hasRisk: !!json.Risk,
                          hasLinks: !!json.Links,
                          hasMeta: !!json.Meta,
                          isOpenBanking: false,
                          messageType: 'unknown'
                        };
                        
                        // Detect Open Banking structure
                        if (json.Data && (json.Data.Account || json.Data.Balance || json.Data.Transaction)) {
                          structure.isOpenBanking = true;
                          structure.messageType = 'open_banking_aisp';
                        } else if (json.Data && json.Data.Initiation) {
                          structure.isOpenBanking = true;
                          structure.messageType = 'open_banking_pisp';
                        }
                        
                        return structure;
                      }

                      extractAuthType(authHeader) {
                        if (!authHeader) return 'none';
                        if (authHeader.startsWith('Bearer ')) return 'bearer_token';
                        if (authHeader.startsWith('Basic ')) return 'basic_auth';
                        if (authHeader.startsWith('DPoP ')) return 'dpop';
                        return 'unknown';
                      }

                      extractImportantResponseHeaders(headers) {
                        const important = {};
                        const headerNames = [
                          'x-fapi-interaction-id',
                          'x-banking-audit-id',
                          'x-compliance-verified',
                          'content-type',
                          'cache-control',
                          'x-ratelimit-remaining',
                          'x-response-time'
                        ];
                        
                        for (const name of headerNames) {
                          if (headers[name]) {
                            important[name] = headers[name];
                          }
                        }
                        
                        return important;
                      }

                      logAuditEvent(eventType, context) {
                        const auditEvent = {
                          eventType: eventType,
                          ...context,
                          hostname: this.getHostname(),
                          serviceVersion: this.getServiceVersion()
                        };
                        
                        // Log to Envoy's access log
                        this.log(LogLevel.info, `BANKING_AUDIT: ${JSON.stringify(auditEvent)}`);
                        
                        // Send to external audit service (if configured)
                        this.sendToAuditService(auditEvent);
                      }

                      logPerformanceMetrics(context) {
                        const metrics = {
                          eventType: 'BANKING_PERFORMANCE_METRICS',
                          transactionId: context.transactionId,
                          endpoint: context.path,
                          method: context.method,
                          statusCode: context.responseStatus,
                          processingTimeMs: context.totalProcessingTimeMs,
                          requestSize: context.requestBodyAnalysis?.size || 0,
                          responseSize: context.responseBodyAnalysis?.size || 0,
                          timestamp: context.completionTimestamp
                        };
                        
                        this.log(LogLevel.info, `BANKING_METRICS: ${JSON.stringify(metrics)}`);
                      }

                      generateComplianceReport(context) {
                        const report = {
                          eventType: 'BANKING_COMPLIANCE_REPORT',
                          transactionId: context.transactionId,
                          auditId: context.auditId,
                          complianceFrameworks: ['PCI_DSS', 'GDPR', 'SOX', 'FAPI'],
                          dataClassification: context.dataClassification,
                          sensitiveDataProcessed: context.requestBodyAnalysis?.containsSensitiveData || false,
                          encryptionUsed: !!context.encryptionLevel,
                          auditTrailComplete: true,
                          regulatoryJurisdiction: context.jurisdiction,
                          timestamp: context.completionTimestamp
                        };
                        
                        this.log(LogLevel.info, `BANKING_COMPLIANCE: ${JSON.stringify(report)}`);
                      }

                      sendToAuditService(auditEvent) {
                        // In a real implementation, this would send to an external audit service
                        // For now, we just ensure it's logged
                        this.log(LogLevel.debug, `Audit event queued for external service: ${auditEvent.eventType}`);
                      }

                      getHostname() {
                        return process.env.HOSTNAME || 'unknown';
                      }

                      getServiceVersion() {
                        return process.env.SERVICE_VERSION || '1.0.0';
                      }

                      generateTransactionId() {
                        return 'TXN_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                      }

                      generateAuditId() {
                        return 'AUDIT_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                      }
                    }

                    class BankingAuditLoggerRootContext {
                      createFilter() {
                        return new BankingAuditLogger(this);
                      }
                    }

                    registerRootContext((rootContext) => new BankingAuditLoggerRootContext(rootContext), "banking_audit_logger");
            configuration:
              "@type": type.googleapis.com/google.protobuf.StringValue
              value: |
                {
                  "audit_service_endpoint": "http://audit-service.banking-system.svc.cluster.local:8080",
                  "max_audit_buffer_size": 1000,
                  "audit_level": "comprehensive"
                }

---
# Banking Circuit Breaker Filter
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: banking-circuit-breaker
  namespace: banking-system
  labels:
    app: banking-system
    version: v1
    feature: circuit-breaker
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_OUTBOUND
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.fault
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.fault.v3.HTTPFault
          abort:
            percentage:
              numerator: 0
              denominator: HUNDRED
            http_status: 503
          delay:
            percentage:
              numerator: 0
              denominator: HUNDRED
            fixed_delay: 0s
          headers:
          - name: ":path"
            string_match:
              prefix: "/api/v1/"
          upstream_cluster: "banking-services"