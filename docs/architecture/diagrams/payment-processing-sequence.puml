@startuml Payment Processing Sequence

!define ACTOR_COLOR #4A90E2
!define CONTROLLER_COLOR #F5A623
!define APPLICATION_COLOR #7ED321
!define DOMAIN_COLOR #BD10E0
!define INFRASTRUCTURE_COLOR #FF6B6B

participant "Customer/Admin" as User ACTOR_COLOR
participant "PaymentController" as Controller CONTROLLER_COLOR
participant "PaymentApplicationService" as PaymentService APPLICATION_COLOR
participant "LoanApplicationService" as LoanService APPLICATION_COLOR
participant "CustomerApplicationService" as CustomerService APPLICATION_COLOR
participant "Payment" as PaymentAggregate DOMAIN_COLOR
participant "Loan" as LoanAggregate DOMAIN_COLOR
participant "LoanInstallment" as Installment DOMAIN_COLOR
participant "PaymentCalculationService" as CalcService DOMAIN_COLOR
participant "PaymentRepository" as PaymentRepo INFRASTRUCTURE_COLOR
participant "EventPublisher" as EventPub INFRASTRUCTURE_COLOR

== Payment Processing Request ==

User -> Controller : POST /api/v1/loans/{loanId}/payments\n{paymentAmount}
activate Controller

Controller -> Controller : Validate request\n(amount > 0)

Controller -> PaymentService : processPayment(ProcessPaymentCommand)
activate PaymentService

== Loan Validation ==

PaymentService -> LoanService : getLoan(loanId)
activate LoanService

LoanService -> LoanAggregate : findById(loanId)
activate LoanAggregate
LoanAggregate --> LoanService : loan details
deactivate LoanAggregate

LoanService --> PaymentService : loan
deactivate LoanService

PaymentService -> PaymentService : Validate loan exists and not fully paid

alt Loan Already Fully Paid
    PaymentService --> Controller : throw BusinessException("Loan is already fully paid")
    Controller --> User : 400 Bad Request
    deactivate PaymentService
    deactivate Controller
else Loan Has Unpaid Installments

== Payment Calculation ==

PaymentService -> LoanAggregate : getUnpaidInstallments()
activate LoanAggregate
LoanAggregate --> PaymentService : List<LoanInstallment>
deactivate LoanAggregate

PaymentService -> CalcService : calculatePayment(installments, amount, paymentDate)
activate CalcService

loop For each unpaid installment (by due date)
    CalcService -> Installment : calculateEffectivePaymentAmount(paymentDate)
    activate Installment

    Installment -> Installment : calculateEarlyPaymentDiscount(paymentDate)\n(amount × 0.001 × daysBefore)
    Installment -> Installment : calculateLatePaymentPenalty(paymentDate)\n(amount × 0.001 × daysAfter)
    Installment -> Installment : Effective amount = base - discount + penalty

    Installment --> CalcService : effective amount
    deactivate Installment

    CalcService -> CalcService : Check if payment amount covers this installment

    break Payment amount insufficient
        CalcService -> CalcService : Stop processing remaining installments
    end
end

CalcService -> CalcService : Validate advance payment rules\n(max 3 months ahead)

CalcService --> PaymentService : PaymentCalculationResult\n{installmentsToPay, totalDiscount, totalPenalty}
deactivate CalcService

alt No Installments Can Be Paid
    PaymentService --> Controller : throw BusinessException("Payment amount insufficient")
    Controller --> User : 400 Bad Request
    deactivate PaymentService
    deactivate Controller
else Installments Can Be Paid

== Payment Creation ==

PaymentService -> PaymentService : Generate PaymentId

PaymentService -> PaymentAggregate : new Payment(paymentId, loanId, paymentAmount)
activate PaymentAggregate

PaymentAggregate -> PaymentAggregate : Set status = INITIATED
PaymentAggregate -> PaymentAggregate : raiseEvent(PaymentInitiated)

PaymentAggregate --> PaymentService : payment instance
deactivate PaymentAggregate

== Installment Payment Processing ==

loop For each installment to pay
    PaymentService -> Installment : processPayment(installmentAmount, paymentDate)
    activate Installment

    Installment -> Installment : Validate not already paid
    Installment -> Installment : Validate full payment (no partial payments)
    Installment -> Installment : Set paidAmount = amount
    Installment -> Installment : Set paymentDate = now
    Installment -> Installment : Set isPaid = true

    deactivate Installment
end

== Loan Status Update ==

PaymentService -> LoanAggregate : isFullyPaid()
activate LoanAggregate
LoanAggregate -> LoanAggregate : Check if all installments are paid
LoanAggregate --> PaymentService : isFullyPaid result
deactivate LoanAggregate

== Payment Result Processing ==

PaymentService -> PaymentService : Create PaymentResult\n{installmentsPaid, totalDiscount, totalPenalty, isLoanFullyPaid}

PaymentService -> PaymentAggregate : processPayment(paymentResult)
activate PaymentAggregate

PaymentAggregate -> PaymentAggregate : Set installmentsPaid, discounts, penalties
PaymentAggregate -> PaymentAggregate : Set status = COMPLETED
PaymentAggregate -> PaymentAggregate : raiseEvent(PaymentProcessed)

PaymentAggregate --> PaymentService : updated payment
deactivate PaymentAggregate

== Persistence ==

PaymentService -> PaymentRepo : save(payment)
activate PaymentRepo
PaymentRepo --> PaymentService : saved payment
deactivate PaymentRepo

== Credit Release (if loan fully paid) ==

alt Loan Fully Paid
    PaymentService -> LoanService : markLoanAsFullyPaid(loanId)
    activate LoanService

    LoanService -> LoanAggregate : markAsPaid()
    activate LoanAggregate
    LoanAggregate -> LoanAggregate : Set isPaid = true
    deactivate LoanAggregate

    LoanService -> CustomerService : releaseCredit(customerId, totalLoanAmount)
    activate CustomerService

    CustomerService -> CustomerService : Release reserved credit
    CustomerService -> EventPub : publishAsync(CreditReleased)
    activate EventPub
    deactivate EventPub

    deactivate CustomerService
    deactivate LoanService

    PaymentService -> EventPub : publishAsync(LoanFullyPaid)
    activate EventPub
    deactivate EventPub
end

== Event Publishing ==

PaymentService -> PaymentService : Get domain events from payment
PaymentService -> EventPub : publishAsync(PaymentProcessed)
activate EventPub
deactivate EventPub

PaymentService -> PaymentAggregate : clearDomainEvents()
activate PaymentAggregate
deactivate PaymentAggregate

PaymentService --> Controller : PaymentResult\n{paymentId, installmentsPaid, totalSpent, isLoanFullyPaid}
deactivate PaymentService

== Response ==

Controller -> Controller : Convert to PaymentResponse DTO
Controller --> User : 201 Created\nPaymentResponse{paymentId, installmentsPaid, totalAmountSpent, message}
deactivate Controller

end
end

== Error Handling (Alternative Flow) ==

group Payment Processing Failure
    PaymentService -> PaymentRepo : save(payment) throws Exception
    activate PaymentRepo
    PaymentRepo --> PaymentService : DatabaseException
    deactivate PaymentRepo

    PaymentService -> PaymentAggregate : markAsFailed("Database error")
    activate PaymentAggregate
    PaymentAggregate -> PaymentAggregate : Set status = FAILED
    deactivate PaymentAggregate

    PaymentService -> PaymentRepo : save(payment)
    activate PaymentRepo
    deactivate PaymentRepo

    PaymentService --> Controller : throw BusinessException
    Controller --> User : 500 Internal Server Error\n{errorCode: "BUSINESS_ERROR"}
end

note over User, EventPub
    <b>Business Rules Enforced:</b>

    1. <b>No Partial Payments:</b> Must pay full installment amount
    2. <b>Payment Order:</b> Earliest unpaid installments first
    3. <b>Advance Payment Limit:</b> Maximum 3 months ahead
    4. <b>Early Payment Discount:</b> amount × 0.001 × days before due
    5. <b>Late Payment Penalty:</b> amount × 0.001 × days after due
    6. <b>Credit Release:</b> Automatic when loan fully paid
end note

note over CalcService
    <b>Payment Calculation Algorithm:</b>

    1. Sort installments by due date
    2. For each installment:
       - Calculate effective amount (base ± discount/penalty)
       - Check if payment covers this installment
       - Add to payment if sufficient funds
    3. Validate advance payment rules
    4. Return calculation result
end note

note over PaymentAggregate
    <b>Payment State Machine:</b>

    INITIATED → PROCESSING → COMPLETED
              ↘ FAILED

    Only INITIATED payments can be processed
    Failed payments cannot be retried
end note

@enduml
