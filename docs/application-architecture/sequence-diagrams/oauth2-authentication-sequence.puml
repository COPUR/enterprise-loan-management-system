@startuml OAuth2.1 Authentication & Authorization Sequence
!theme plain

skinparam backgroundColor #FAFAFA
skinparam participant {
    BackgroundColor #E8F4FD
    BorderColor #2196F3
}
skinparam actor {
    BackgroundColor #FFE0B2
    BorderColor #FF9800
}

title OAuth2.1 Authentication & Authorization Flow\nwith Keycloak, LDAP, and Party Data Management

actor "Banking User" as User #FFE0B2
participant "Banking Application" as App #E8F4FD
participant "API Gateway" as Gateway #F5F5F5
participant "Keycloak OAuth2.1" as Keycloak #E3F2FD
participant "LDAP Identity Provider" as LDAP #F0F4C3
participant "Party Data Management" as PartyDB #FCE4EC
participant "Banking Domain Service" as BankingService #E1F5FE
database "PostgreSQL" as DB #FF6B6B

== Initial Authentication Flow ==

User -> App : 1. Access Banking Application\n/login
App -> Gateway : 2. Redirect to OAuth2.1\nAuthorization Endpoint
Gateway -> Keycloak : 3. GET /realms/banking-realm/protocol/\nopenid-connect/auth\n+ client_id, redirect_uri, code_challenge

note over Keycloak
    **OAuth2.1 Security Features:**
    - PKCE code challenge validation
    - Client authentication
    - Banking realm validation
    - Session security checks
end note

Keycloak -> User : 4. Show Login Form\n(Banking Theme)

User -> Keycloak : 5. Submit Credentials\n(username, password)

Keycloak -> LDAP : 6. Authenticate User\nLDAP Bind Request
LDAP -> Keycloak : 7. Authentication Result\n+ User Attributes

note over LDAP
    **LDAP User Attributes:**
    - uid: john.smith
    - cn: John Smith  
    - department: Loans
    - title: Senior Loan Officer
    - employeeNumber: EMP002
    - groups: loan-officers, banking-operations
end note

== Role Resolution & Authorization ==

Keycloak -> PartyDB : 8. Query Party Roles\nGET /api/parties/john.smith/roles
PartyDB -> DB : 9. Fetch Active Roles\nSELECT * FROM party_roles WHERE...
DB -> PartyDB : 10. Return Role Data
PartyDB -> Keycloak : 11. Return Authoritative Roles\n[LOAN_OFFICER, LOAN_MANAGER]

note over PartyDB
    **Party Role Data:**
    - Role: LOAN_OFFICER
    - Authority Level: 7
    - Monetary Limit: $500,000
    - Business Unit: Commercial Loans
    - Effective Until: 2025-12-31
    - Last Review: 2024-06-01
end note

== Token Generation & Response ==

Keycloak -> Keycloak : 12. Generate JWT Token\nInclude roles, claims, audit info

note over Keycloak
    **JWT Token Claims:**
    - sub: john.smith@banking.local
    - realm_access.roles: [LOAN_OFFICER]
    - banking_roles: [LOAN_OFFICER, LOAN_MANAGER]
    - banking_groups: [loan-officers, banking-operations]
    - monetary_limit: 500000
    - authority_level: 7
    - business_unit: Commercial Loans
    - session_id: 12345-abcde
    - iat, exp, iss, aud
end note

Keycloak -> User : 13. Authorization Code Response\nRedirect with code + state
User -> App : 14. Follow Redirect\nwith Authorization Code
App -> Keycloak : 15. Token Exchange\nPOST /realms/banking-realm/protocol/\nopenid-connect/token\n+ code, code_verifier, client_secret

Keycloak -> App : 16. Access Token Response\nJWT + Refresh Token + ID Token

== Business Authorization Check ==

App -> BankingService : 17. API Request with JWT\nGET /api/loans/12345\nAuthorization: Bearer <jwt_token>

BankingService -> BankingService : 18. Validate JWT Signature\nUsing Keycloak public key
BankingService -> PartyDB : 19. Verify Current Role Status\nGET /api/parties/john.smith/roles/current

PartyDB -> DB : 20. Check Role Validity\nValidate effective dates, review status
DB -> PartyDB : 21. Return Role Status\nActive, not expired, reviewed
PartyDB -> BankingService : 22. Confirm Authorization\nRole valid for requested operation

note over BankingService
    **Authorization Logic:**
    - JWT signature valid ✓
    - Token not expired ✓  
    - User has LOAN_OFFICER role ✓
    - Role not expired ✓
    - Role review up to date ✓
    - Monetary limit sufficient ✓
    - Business unit matches ✓
end note

BankingService -> DB : 23. Execute Business Operation\nSELECT loan_data WHERE...
DB -> BankingService : 24. Return Business Data
BankingService -> App : 25. API Response\nLoan data + authorization context

== Audit & Compliance Logging ==

parallel
    BankingService -> PartyDB : 26a. Log Access Event\nUser accessed loan 12345
    BankingService -> Keycloak : 26b. Log Authorization Event\nSuccessful role-based access
end

parallel
    PartyDB -> DB : 27a. Store Audit Record\nINSERT INTO audit_log...
    Keycloak -> Keycloak : 27b. Event Logging\nUser access event recorded
end

App -> User : 28. Display Loan Information\nwith Role-based UI

== Session Management & Refresh ==

alt Token Near Expiry
    App -> Keycloak : 29. Refresh Token Request\nPOST /token + refresh_token
    Keycloak -> PartyDB : 30. Re-validate Roles\nCheck for role changes
    PartyDB -> Keycloak : 31. Current Role Status
    Keycloak -> App : 32. New Access Token\nUpdated claims if roles changed
end

== Error Scenarios ==

alt Authentication Failure
    LDAP -> Keycloak : Authentication Failed
    Keycloak -> Keycloak : Log Failed Attempt\nIncrement failure counter
    Keycloak -> User : Login Error Response\nWith rate limiting
end

alt Role Authorization Failure  
    PartyDB -> BankingService : Role Expired/Suspended
    BankingService -> App : 403 Forbidden\nInsufficient authorization
    BankingService -> PartyDB : Log Authorization Failure
end

alt Token Validation Failure
    BankingService -> BankingService : Invalid JWT Signature
    BankingService -> App : 401 Unauthorized\nInvalid token
    BankingService -> Keycloak : Report Token Issue
end

note bottom
    **Key Security Features:**
    • OAuth2.1 with PKCE for enhanced security
    • Multi-layer authorization (Keycloak + LDAP + Party DB)
    • Temporal role management with expiration
    • Comprehensive audit logging
    • Banking compliance integration
    • Real-time role validation
    • Monetary limit enforcement
    • Business unit access control
end note

@enduml