stages:
  - governance
  - validate
  - quality
  - security
  - build
  - publish

variables:
  SERVICE_DIR: "."
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  STRICT_DEPRECATED_ROOTS: "true"

repository_governance:
  stage: governance
  image: python:3.13-slim
  script:
    - apt-get update
    - apt-get install -y --no-install-recommends git bash
    - python -m venv .venv-validation
    - . .venv-validation/bin/activate
    - python -m pip install --upgrade pip coverage
    - python -m coverage run --source=tools/validation -m unittest discover -s tools/validation/tests -p 'test_*.py'
    - python -m coverage report --include='*/repo_governance_validator.py' --fail-under=90
    - bash tools/validation/validate-repo-governance.sh

validate_workspace:
  stage: validate
  image: eclipse-temurin:23-jdk
  script:
    - test -f "${SERVICE_DIR}/build.gradle"
    - test -x ./gradlew

quality_gate:
  stage: quality
  image: eclipse-temurin:23-jdk
  script:
    - ./gradlew -p "${SERVICE_DIR}" --no-daemon clean check

dependency_report:
  stage: security
  image: eclipse-temurin:23-jdk
  script:
    - mkdir -p "${SERVICE_DIR}/build/reports/security"
    - ./gradlew -p "${SERVICE_DIR}" --no-daemon dependencies > "${SERVICE_DIR}/build/reports/security/dependencies.txt"
  artifacts:
    when: always
    paths:
      - "${SERVICE_DIR}/build/reports/security/dependencies.txt"

vulnerability_scan:
  stage: security
  image:
    name: aquasec/trivy:0.53.0
    entrypoint: [""]
  script:
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL "${SERVICE_DIR}"

secret_scan:
  stage: security
  image:
    name: zricethezav/gitleaks:v8.21.2
    entrypoint: [""]
  script:
    - gitleaks detect --no-git --source "${SERVICE_DIR}" --exit-code 1

build_image:
  stage: build
  image: docker:26.1.3
  services:
    - docker:26.1.3-dind
  variables:
    DOCKER_DRIVER: overlay2
    IMAGE_NAME: "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"
  script:
    - |
      if [ -f "${SERVICE_DIR}/infrastructure/Dockerfile" ]; then
        docker build -t "${IMAGE_NAME}" -f "${SERVICE_DIR}/infrastructure/Dockerfile" "${SERVICE_DIR}"
      else
        docker build -t "${IMAGE_NAME}" "${SERVICE_DIR}"
      fi
    - docker save "${IMAGE_NAME}" > image.tar
  artifacts:
    when: always
    paths:
      - image.tar

publish_image:
  stage: publish
  image: docker:26.1.3
  services:
    - docker:26.1.3-dind
  variables:
    IMAGE_NAME: "${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHA}"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
  script:
    - docker load < image.tar
    - echo "${CI_REGISTRY_PASSWORD}" | docker login "${CI_REGISTRY}" --username "${CI_REGISTRY_USER}" --password-stdin
    - docker push "${IMAGE_NAME}"
